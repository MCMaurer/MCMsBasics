devtools::document()
install.packages("ggplot2", "dplyr")
install.packages(c("ggplot2", "dplyr"))
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
packrat::set_opts(auto.snapshot = TRUE)
packrat::snapshot()
install.packages("plogr")
packrat::snapshot()
install.packages("BH")
packrat::snapshot()
packrat::status()
devtools::document()
devtools::document()
devtools::use_vignette("my-vignette")
devtools::load_all()
MCMsBasics::minimal_ggplot_theme(base_family = base_family)
MCMsBasics::minimal_ggplot_theme()
devtools::use_testthat()
devtools::document()
install.packages("testthat")
install.packages("devtools")
install.packages("ggplot2")
install.packages("dplyr")
library(MCMsBasics)
?scales::trans_new
library(MCMsBasics)
library(MCMsBasics)
devtools::document()
install.packages("devtools")
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
scale_y_quantile()
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(mpg)
library(dplyr)
library(ggplot2)
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(mpg)
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(!!mpg)
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(mtcars$mpg)
scale_y_continuous(..., trans = quantile_trans(val, prob, digits))
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, ...) {
scale_y_continuous(..., trans = quantile_trans(val, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(mtcars$mpg)
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, ...) {
scale_y_continuous(..., trans = quantile_trans(val = .$!!x, prob, digits))
}
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, ...) {
scale_y_continuous(..., trans = quantile_trans(val = .$!!x, prob, digits))
}
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, ...) {
x <- enquo(x)
scale_y_continuous(..., trans = quantile_trans(val = .$x, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(mpg)
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, ...) {
x <- enquo(val)
scale_y_continuous(..., trans = quantile_trans(val = .$x, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(mpg)
scale_y_continuous(..., trans = quantile_trans(val = data$x, prob, digits))
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, ...) {
x <- enquo(val)
scale_y_continuous(..., trans = quantile_trans(val = data$x, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(mpg)
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, ...) {
x <- enquo(val)
data <- data
scale_y_continuous(..., trans = quantile_trans(val = data$x, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(mpg)
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(mpg)
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(mtcars$mpg)
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, ...) {
scale_y_continuous(..., trans = quantile_trans(val, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(mtcars$mpg)
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, ...) {
x <- !!aesthetics
scale_y_continuous(..., trans = quantile_trans(val = .$x, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(aesthetics = "y")
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, aesthetics, ...) {
x <- !!aesthetics
scale_y_continuous(..., trans = quantile_trans(val = .$x, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(aesthetics = "y")
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, aesthetics, ...) {
x <- enquo(aesthetics)
scale_y_continuous(..., trans = quantile_trans(val = .$x, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(aesthetics = "y")
scale_y_continuous(..., trans = quantile_trans(val = mtcars$x, prob, digits))
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, aesthetics, ...) {
x <- enquo(aesthetics)
scale_y_continuous(..., trans = quantile_trans(val = mtcars$x, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(aesthetics = "y")
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, aesthetics, ...) {
scale_y_continuous(..., trans = quantile_trans(val = mtcars$!!aesthetics, prob, digits))
}
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, aesthetics, ...) {
x <- !!aesthetics
scale_y_continuous(..., trans = quantile_trans(val = mtcars$x, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(aesthetics = "y")
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, aesthetics, ...) {
x <- expr(aesthetics)
scale_y_continuous(..., trans = quantile_trans(val = mtcars$x, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(aesthetics = "y")
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, ...) {
scale_y_continuous(..., trans = quantile_trans(val, prob, digits))
}
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, ...) {
scale_y_continuous(..., trans = quantile_trans(val = mtcars$val, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(val = mpg)
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(val = "mpg")
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(val = "mpg")
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(val = "mpg")
#' Set the y axis scale to continuous with quantile breaks
#'
#' @param val: the column to calculate breaks from, ie mtcars$mpg
#' @param prob: a sequence of probability values, ie c(0, 0.5, 1) or seq(0, 1, 0.25)
#' @param digits: number of digits to round the quantiles to
#'
#' @return
#' @export
#' @import ggplot2
#'
scale_y_quantile <- function(val, prob = seq(0, 1, 0.25), digits = 1, ...) {
scale_y_continuous(..., trans = quantile_trans(val, prob, digits))
}
mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point() + scale_y_quantile(val = mtcars$mpg)
p <- mtcars %>% ggplot(aes(x = wt, y = mpg)) + geom_point()
p
p$mapping$x
library(tidyverse)
test <- tibble(height = rexp(20, 10), time = 1:20)
test[c(4, 11, 12, 17, 19),1] <- NA
test %>%
mutate(gap = case_when((is.na(lag(height)) |
is.na(lead(height))) &
!is.na(height) &
time != min(time) ~ TRUE,
(!is.na(lag(height)) |
!is.na(lead(height))) & !is.na(height) ~ FALSE,
TRUE ~ NA),
two_groups = is.na(lag(height)) &
is.na(lead(height)) &
time != min(time) &
time != max(time)) %>%
bind_rows(., filter(., two_groups)) %>%
arrange(time) %>%
group_by(gap) %>%
mutate(group = ceiling(row_number()/2)) %>%
ungroup() %>%
mutate(gap = ifelse(gap, group, NA)) %>%
ggplot(aes(x = time, y = height)) +
geom_point() +
geom_line() +
geom_line(data = . %>% filter(!is.na(height), gap > 0), aes(group = gap), lty = "dashed") +
theme_bw()
library(tidyverse)
test <- tibble(height = rexp(20, 10), time = 1:20)
test[c(4, 11, 12, 17, 19),1] <- NA
test %>%
mutate(gap = case_when((is.na(lag(height)) |
is.na(lead(height))) &
!is.na(height) &
time != min(time) ~ TRUE,
(!is.na(lag(height)) |
!is.na(lead(height))) & !is.na(height) ~ FALSE,
TRUE ~ NA),
two_groups = is.na(lag(height)) &
is.na(lead(height)) &
time != min(time) &
time != max(time)) %>%
bind_rows(., filter(., two_groups)) %>%
arrange(time) %>%
group_by(gap) %>%
mutate(group = ceiling(row_number()/2)) %>%
ungroup() %>%
mutate(gap = ifelse(gap, group, NA)) %>%
ggplot(aes(x = time, y = height)) +
geom_point() +
geom_line() +
geom_line(data = . %>% filter(!is.na(height), gap > 0), aes(group = gap), lty = "dashed") +
theme_bw()
library(tidyverse)
library(dplyr)
test <- tibble(height = rexp(20, 10), time = 1:20)
test[c(4, 11, 12, 17, 19),1] <- NA
test %>%
mutate(gap = case_when((is.na(lag(height)) |
is.na(lead(height))) &
!is.na(height) &
time != min(time) ~ TRUE,
(!is.na(lag(height)) |
!is.na(lead(height))) & !is.na(height) ~ FALSE,
TRUE ~ NA),
two_groups = is.na(lag(height)) &
is.na(lead(height)) &
time != min(time) &
time != max(time)) %>%
bind_rows(., filter(., two_groups)) %>%
arrange(time) %>%
group_by(gap) %>%
mutate(group = ceiling(row_number()/2)) %>%
ungroup() %>%
mutate(gap = ifelse(gap, group, NA)) %>%
ggplot(aes(x = time, y = height)) +
geom_point() +
geom_line() +
geom_line(data = . %>% filter(!is.na(height), gap > 0), aes(group = gap), lty = "dashed") +
theme_bw()
library(ggplot2)
test <- tibble(height = rexp(20, 10), time = 1:20)
test[c(4, 11, 12, 17, 19),1] <- NA
test %>%
mutate(gap = case_when((is.na(lag(height)) |
is.na(lead(height))) &
!is.na(height) &
time != min(time) ~ TRUE,
(!is.na(lag(height)) |
!is.na(lead(height))) & !is.na(height) ~ FALSE,
TRUE ~ NA),
two_groups = is.na(lag(height)) &
is.na(lead(height)) &
time != min(time) &
time != max(time)) %>%
bind_rows(., filter(., two_groups)) %>%
arrange(time) %>%
group_by(gap) %>%
mutate(group = ceiling(row_number()/2)) %>%
ungroup() %>%
mutate(gap = ifelse(gap, group, NA)) %>%
ggplot(aes(x = time, y = height)) +
geom_point() +
geom_line() +
geom_line(data = . %>% filter(!is.na(height), gap > 0), aes(group = gap), lty = "dashed") +
theme_bw()
library(dplyr)
library(ggplot2)
test <- tibble(height = rexp(20, 10), time = 1:20)
test[c(4, 11, 12, 17, 19),1] <- NA
test %>%
mutate(gap = case_when((is.na(lag(height)) |
is.na(lead(height))) &
!is.na(height) &
time != min(time) ~ TRUE,
(!is.na(lag(height)) |
!is.na(lead(height))) & !is.na(height) ~ FALSE,
TRUE ~ NA),
two_groups = is.na(lag(height)) &
is.na(lead(height)) &
time != min(time) &
time != max(time)) %>%
bind_rows(., filter(., two_groups)) %>%
arrange(time) %>%
group_by(gap) %>%
mutate(group = ceiling(row_number()/2)) %>%
ungroup() %>%
mutate(gap = ifelse(gap, group, NA)) %>%
ggplot(aes(x = time, y = height)) +
geom_point() +
geom_line() +
geom_line(data = . %>% filter(!is.na(height), gap > 0), aes(group = gap), lty = "dashed") +
theme_bw()
mtcars
iris
devtools::build()
install.packages(c("akima", "ape", "aws.signature", "backports", "bayesplot", "benchmarkme", "blogdown", "bookdown", "brms", "broman", "car", "carData", "countrycode", "dbplyr", "DiagrammeR", "dplyr", "effectsize", "ellipsis", "emmeans", "fitdistrplus", "foreign", "gargle", "gender", "ggplot2", "ggraph", "ggspatial", "glue", "gmp", "googledrive", "googlesheets4", "haven", "HDInterval", "httpuv", "insight", "jomo", "jsonify", "keras", "later", "lwgeom", "mapdeck", "maptools", "mice", "mnormt", "modelr", "modelStudio", "ncmeta", "nlme", "officer", "openxlsx", "parameters", "pdftools", "pillar", "pkgbuild", "pkgload", "ps", "RcppArmadillo", "renv", "reticulate", "rgdal", "rgeos", "rmarkdown", "rsample", "rversions", "RWiener", "scales", "servr", "sf", "sfheaders", "showtext", "showtextdb", "sjlabelled", "sjmisc", "sjPlot", "sjstats", "slider", "sp", "SQUAREM", "StanHeaders", "sysfonts", "systemfonts", "tensorflow", "tidygraph", "tidyr", "tidyselect", "tinytex", "tufte", "V8", "vctrs", "xfun"))
install.packages(c("boot", "class", "foreign", "KernSmooth", "MASS", "nlme", "nnet", "spatial"), lib="/Users/MJ/GitHub/MCMsBasics/packrat/lib-R/x86_64-apple-darwin17.0/4.0.0")
install.packages(c("boot", "class", "foreign", "KernSmooth", "MASS", "nlme", "nnet", "spatial"), lib="/Users/MJ/GitHub/MCMsBasics/packrat/lib-R/x86_64-apple-darwin17.0/4.0.0")
packrat::snapshot(prompt = FALSE)
packrat::restore(prompt = FALSE)
packrat::restore(prompt = FALSE)
library(MCMsBasics)
nice_names()
quantile_breaks()
nice_names
library(MCMsBasics)
nice_names
nice_names()
roxygen2::roxygenise()
install.packages(c("devtools", "roxygen2"))
library(MCMsBasics)
install.packages("dplyr")
library(MCMsBasics)
nice_names()
roxygen2::roxygenise()
library(MCMsBasics)
nice_names()
iris %>% nice_names()
nice_names(iris)
nice_names(mtcars)
iris %>%
rename_all(~ str_to_lower(.) %>%
str_replace_all(., " ", "_") %>%
str_replace_all(., ".", "_")
)
library(tidyverse)
library(dplyr)
library(magrittr)
library(stringr)
iris %>%
rename_all(~ str_to_lower(.) %>%
str_replace_all(., " ", "_") %>%
str_replace_all(., ".", "_")
)
iris %>%
rename_all(~ str_to_lower(.) %>%
str_replace_all(., " ", "_")
)
iris %>%
rename_all(~ str_to_lower(.) %>%
str_replace_all(., " ", "_") %>%
)
iris %>%
rename_all(~ str_to_lower(.) %>%
str_replace_all(., " ", "_") %>%
str_replace_all(., "\.", "_")
)
iris %>%
rename_all(~ str_to_lower(.) %>%
str_replace_all(., " ", "_") %>%
str_replace_all(., "\\.", "_")
)
library(MCMsBasics)
nice_names(iris)
